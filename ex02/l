#include "AAnimal.hpp"

AAnimal::AAnimal()
{
    this -> type = "AAnimal";
    std:: cout << "AAnimal default constructor" << std::endl;
}
AAnimal::~AAnimal()
{
    std:: cout << "AAnimal destructor" << std::endl;
}
AAnimal &AAnimal::operator=(const AAnimal&o)
{
    this->type = o.type;
    std:: cout << "AAnimal copy assignment "<< std::endl;
    return *this;
}
AAnimal::AAnimal(const AAnimal & o)
{
    *this = o;
    std:: cout << "AAnimal copy constructor "<< std::endl;
}
std::string AAnimal::getType()const {return(type);}#ifndef AANIMAL_HPP
#define AANIMAL_HPP

#include <iostream>

class AAnimal
{
    protected:
        std::string type;
    public:
        AAnimal();
        AAnimal(const  AAnimal &o);
        virtual ~AAnimal();
        AAnimal &operator=(const  AAnimal &o);
        virtual void makeSound() const = 0;
        
        std::string getType() const ;
};
#endif#include "Cat.hpp"

Cat::Cat()
{
    this -> type = "Cat";
    std:: cout << "Cat default constructor" << std::endl;
    brain = new Brain;
}
Cat::~Cat()
{
    delete brain;
    std:: cout << "Cat destructor" << std::endl;
}
Brain* Cat::getBrain() const {
    return brain;
}
Cat &Cat::operator=(const Cat&o)
{
    this->type = o.type;
    this->brain = o.brain;
    std:: cout << "Cat copy assignment "<< std::endl;
    return (*this);
}

void Cat::makeSound() const
{
    std:: cout << "Meow!"<< std::endl;
}
Cat::Cat(const Cat & o)
{    
    if(&o != this)
        *this = o;
    std:: cout << "Cat copy constructor "<< std::endl;
}#ifndef CAT_HPP
#define CAT_HPP

#include "Animal.hpp"
#include "AAnimal.hpp"
#include "Brain.hpp"

class Cat : public AAnimal
{
    private:
        Brain *brain;
    public:
        Cat();
        Cat(const  Cat &o);
        ~Cat();
        void makeSound()const ;
        Cat &operator=(const  Cat &o);
        Brain* getBrain() const ;
};

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Brain.cpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yojablao <yojablao@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 21:35:12 by yojablao          #+#    #+#             */
/*   Updated: 2025/05/05 18:12:49 by yojablao         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#include "Brain.hpp"

Brain::Brain()
{
    
    std:: cout << "Brain default constructor" << std::endl;
}
Brain::~Brain()
{
    std:: cout << "Brain destructor" << std::endl;
}
Brain &Brain::operator=(const Brain&o)
{
    if(this != &o)
    {
        for(int i = 0;i < 100 ;i++)
        {
            this->ideas[i] = o.ideas[i];
        }
    }
    std:: cout << "Brain copy assignment "<< std::endl;
    return (*this);
}

const std::string &Brain::getIdea(unsigned int i)const
{
    return (this->ideas[i]);
}
void Brain::setIdea(int i, const std::string& idea)
{
    this->ideas[i] = idea;   
}
Brain::Brain(const Brain & o)
{
    *this = o;
    std:: cout << "Brain copy constructor "<< std::endl;
}#ifndef BRAIN_HPP
#define BRAIN_HPP
#include <iostream>
class Brain
{
    private:
    std::string ideas[100];

    public:
    Brain();
    Brain(const Brain &o);
    Brain &operator=(const Brain &o);
    const std::string& getIdea(unsigned int i) const;
    void setIdea(int index, const std::string& idea);
    ~Brain();
};
#endif#include "Dog.hpp"

Dog::Dog()
{
    this -> type = "Dog";
    std:: cout << "Dog default constructor" << std::endl;
    brain = new Brain;
}
Dog::~Dog()
{
    std:: cout << "Dog destructor" << std::endl;
    delete brain;
}
Brain* Dog::getBrain() const {
    return brain;
}
Dog& Dog::operator=(const Dog& o)
{
    std::cout << "Dog copy assignment " << std::endl;
    if (this != &o)
    {
        this->type = o.type;
        delete this->brain;
        this->brain = new Brain(*o.brain);
    }
    return *this;
}
void Dog::makeSound() const
{
    std:: cout << "Woof! Woof!"<< std::endl;
}
Dog::Dog(const Dog & o)
{    
    std:: cout << "Dog copy constructor "<< std::endl;
    if(&o != this)
        *this = o;
}#ifndef DOG_HPP
#define DOG_HPP

#include "Animal.hpp"
#include "AAnimal.hpp"
#include "Brain.hpp"

class Dog : public AAnimal
{
    private:
        Brain * brain;
    public:
        Dog();
        Dog(const  Dog &o);
        ~Dog();
        Dog &operator=(const  Dog &o);
        void makeSound()const;
        Brain* getBrain() const ;
};

#endif