#include "AMateria.hpp"

AMateria::AMateria(std::string const & t) : type(t) {}
void AMateria::use(ICharacter& target){(void)target;}
std::string const &AMateria::getType() const { return type; }
AMateria& AMateria::operator=(const AMateria &o)
{
    if(this != &o)
        this->type =  o.type;
    return(*this);
}
AMateria::AMateria(const AMateria &o)
{
    *this  = o;
}// Character.cpp
#include "Character.hpp"

Character::Character(std::string const & name) : _name(name) {
    for (int i = 0; i < 4; ++i)
        stor[i] = nullptr;
}

Character::Character(const Character& other) : _name(other._name) {
    for (int i = 0; i < 4; ++i) {
        if (other.stor[i])
            stor[i] = other.stor[i]->clone();
        else
            stor[i] = nullptr;
    }
}

Character& Character::operator=(const Character& other) {
    if (this != &other) {
        _name = other._name;
        for (int i = 0; i < 4; ++i) {
            delete stor[i];
            if (other.stor[i])
                stor[i] = other.stor[i]->clone();
            else
                stor[i] = nullptr;
        }
    }
    return *this;
}

Character::~Character() {
    for (int i = 0; i < 4; ++i)
        delete stor[i];
}

std::string const & Character::getName() const {
    return _name;
}

void Character::equip(AMateria* m) {
    if (!m) return;
    for (int i = 0; i < 4; ++i) {
        if (!stor[i]) {
            stor[i] = m;
            return;
        }
    }
}

void Character::unequip(int idx) {
    if (idx < 0 || idx >= 4) return;
    stor[idx] = nullptr;
}

void Character::use(int idx, ICharacter& target) {
    if (idx < 0 || idx >= 4) return;
    if (stor[idx])
        stor[idx]->use(target);
}
#include "Cure.hpp"

Cure::Cure():AMateria("Cure")
{
    std:: cout << "Cure default constructor" << std::endl;
}
Cure::Cure(const Cure &o):AMateria("Cure")
{
    *this = o;
    std:: cout << "Cure default constructor" << std::endl;
}
Cure::~Cure()
{
    std:: cout << "Cure destructor" << std::endl;
}
AMateria *Cure::clone() const
{
    return(new Cure(*this));
}
Cure &Cure::operator=(const Cure &o)
{
    std:: cout << "Cure copy assignment "<< std::endl;
     if (this != &o) 
    {
        AMateria::operator=(o);
        std:: cout << "Cure copy  assignment"<< std::endl;
    }
    return (*this);
}
void Cure::use(ICharacter &target)
{
    std::cout << "* heals  " << target.getName() << "â€™s wounds *"<<std::endl;
}
#include "Ice.hpp"

Ice::Ice():AMateria("ice")
{
    std:: cout << "Ice default constructor" << std::endl;
}
Ice::Ice(const Ice &o):AMateria("ice")
{
    *this = o;
    std:: cout << "Ice default constructor" << std::endl;
}
Ice::~Ice()
{
    std:: cout << "Ice destructor" << std::endl;
}
AMateria *Ice::clone() const
{
    return(new Ice(*this));
}
Ice &Ice::operator=(const Ice &o)
{
    std:: cout << "Ice copy assignment "<< std::endl;
     if (this != &o) 
    {
        AMateria::operator=(o);
        std:: cout << "Ice copy  assignment"<< std::endl;
    }
    return (*this);
}
void Ice::use(ICharacter &target)
{
    std::cout << "* shoots an ice bolt at " << target.getName() << " *"<< std::endl;
}
// MateriaSource.cpp
#include "MateriaSource.hpp"
#include <iostream>

MateriaSource::MateriaSource() {
    for (int i = 0; i < 4; ++i)
        _materias[i] = nullptr;
}

MateriaSource::MateriaSource(const MateriaSource& other) {
    for (int i = 0; i < 4; ++i)
        _materias[i] = other._materias[i] ? other._materias[i]->clone() : nullptr;
}

MateriaSource& MateriaSource::operator=(const MateriaSource& other) {
    if (this != &other) {
        for (int i = 0; i < 4; ++i) {
            delete _materias[i];
            _materias[i] = other._materias[i] ? other._materias[i]->clone() : nullptr;
        }
    }
    return *this;
}

MateriaSource::~MateriaSource() {
    for (int i = 0; i < 4; ++i)
        delete _materias[i];
}

void MateriaSource::learnMateria(AMateria* m) {
    if (!m) return;
    for (int i = 0; i < 4; ++i) {
        if (!_materias[i]) {
            _materias[i] = m;
            return;
        }
    }
    delete m; 
}

AMateria* MateriaSource::createMateria(const std::string& type) {
    for (int i = 0; i < 4; ++i) {
        if (_materias[i] && _materias[i]->getType() == type)
            return _materias[i]->clone();
    }
    return nullptr;
}
// #include "IMateriaSource.hpp" 
#include "MateriaSource.hpp" 
#include "Ice.hpp" 
#include "Cure.hpp" 
#include "Character.hpp" 
int main()
{
    IMateriaSource* src = new MateriaSource();
    src->learnMateria(new Ice());
    src->learnMateria(new Cure());
    ICharacter* me = new Character("me");
    AMateria* tmp;
    tmp = src->createMateria("ice");
    me->equip(tmp);
    tmp = src->createMateria("cure");
    me->equip(tmp);
    ICharacter* bob = new Character("bob");
    me->use(0, *bob);
    me->use(1, *bob);
    delete bob;
    delete me;
delete src;

}#ifndef AMATERIA_HPP
#define AMATERIA_HPP

#include <iostream>
#include "ICharacter.hpp"

#include <string>
class ICharacter;
class AMateria 
{
protected:
    std::string type;

public:
    AMateria(std::string const &type);
    AMateria(const AMateria &type);
    virtual ~AMateria() {}
    AMateria &operator=(const AMateria &o);
    std::string const & getType() const;

    virtual AMateria* clone() const = 0;

    virtual void use(ICharacter& target);
};
#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Character.hpp                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yojablao <yojablao@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/06 17:10:38 by yojablao          #+#    #+#             */
/*   Updated: 2025/05/06 17:20:55 by yojablao         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CHARACTER_HPP
#define CHARACTER_HPP

#include "ICharacter.hpp"
#include "AMateria.hpp"
#include <string>

class Character : public ICharacter {
private:
    std::string _name;
    AMateria* stor[4];

public:
    Character(std::string const & name);
    Character(const Character& other);
    Character& operator=(const Character& other);
    virtual ~Character();

    std::string const & getName() const;
    void equip(AMateria* m);
    void unequip(int idx);
    void use(int idx, ICharacter& target);
};

#endif#ifndef CURE_HPP
#define CURE_HPP

#include "AMateria.hpp"

class Cure : public AMateria {
public:
    Cure();
    Cure(const Cure& other);
    Cure& operator=(const Cure& other);
    virtual ~Cure();

    AMateria* clone() const ;
    void use(ICharacter& target) ;
};
#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ICharacter.hpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yojablao <yojablao@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 23:10:16 by yojablao          #+#    #+#             */
/*   Updated: 2025/05/06 17:24:40 by yojablao         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ICHARACTER_HPP
#define ICHARACTER_HPP
#include "AMateria.hpp"

class AMateria;
class ICharacter
{
    public:
        virtual ~ICharacter(){}
        virtual std::string const & getName() const = 0;
        virtual void equip(AMateria* m) = 0;
        virtual void unequip(int idx) = 0;
        virtual void use(int idx, ICharacter& target) = 0;
};
#endif#ifndef IMATERIASOURCE_HPP
#define IMATERIASOURCE_HPP

#include "AMateria.hpp"
// #include "AMateria.hpp"

class IMateriaSource
{
    public:
        virtual ~IMateriaSource() {}
        virtual void learnMateria(AMateria*) = 0;
        virtual AMateria* createMateria(std::string const & type) = 0;
};
#endif#ifndef ICE_HPP
#define ICE_HPP

#include "AMateria.hpp"
#include "ICharacter.hpp"

class Ice : public AMateria {
public:
    Ice();
    Ice(const Ice& other);
    Ice& operator=(const Ice& other);
    virtual ~Ice();

    AMateria* clone() const ;
    void use(ICharacter& target);
};

#endif #ifndef MATERIASOURCE_HPP
#define MATERIASOURCE_HPP

#include "IMateriaSource.hpp"

class MateriaSource : public IMateriaSource {
private:
    AMateria* _materias[4]; // Store up to 4 learned materias
public:
    MateriaSource();
    MateriaSource(const MateriaSource& other);
    MateriaSource& operator=(const MateriaSource& other);
    virtual ~MateriaSource();

    void learnMateria(AMateria* m);
    AMateria* createMateria(std::string const & type);
};

#endif